# 算法

## 字符串

### 回文 (字符串倒置)
    
    com.str.ReverseStr
    
## 动态规划

### 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。  
示例 1：输入: "babad"  输出: "bab"  注意: "aba" 也是一个有效答案。  
示例 2：输入: "cbbd"  输出: "bb"

思路：
```
dp[i][j]表示“以s[i]开始s[j]结尾的回文串的长度。如果这个字符串不是回文串，让dp[i][j]=0”。显然，j>=i，只需往dp填j>=i的部分即可。

dp[i][j]的递推公式可以这么表述：

（1）首先对dp的对角线元素初始化为1，也就是当i==j时，dp[i][j]=1。

这很显然，每个单独的字符其实就是个长度为1的回文串。

（2）当j-i==1：

若s[i]==s[j]，则dp[i][j]=2；否则dp[i][j]=0。

解释：当j-i==1时，若s[i]==s[j]，则s[i]和s[j]可以组成一个长度为2的回文串。若s[i]！=s[j]，显然他们不可能组成回文串，dp[i][j]=0。

（3）当j-i>=2：

若s[i]==s[j]：若dp[i+1][j-1]>0，则dp[i][j]= dp[i + 1][j - 1] + 2;否则dp[i][j]= 0;

若s[i]！=s[j]：dp[i][j]=0。

解释：如果s[i]==s[j]，表明这个子串有可能是回文串。当去头去尾后它是回文串时，就可以在去头去尾的那个回文串长度基础上+2，得到它的长度。如果去头去尾后不是回文串，那这个子串一定不是回文串，回文串长度只能是0。

若s[i]！=s[j]，显然他们不可能组成回文串，dp[i][j]=0。

只需找到dp[i][j]的最大元素和它对应的i和j就可以得到结果“s中最长回文子串”。


另外还有一个要注意的点：因为需要访问dp[i+1][j-1]，因此i是从大到小的，j是从小到大的。j从0到size-1，i从j-1到0。
```
 
### 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
示例:  
输入: [-2,1,-3,4,-1,2,1,-5,4],  
输出: 6  
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。  
进阶:  
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。  

### 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

```
示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3


```

结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)


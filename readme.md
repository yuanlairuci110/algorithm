# 算法

## 字符串

### 回文 (字符串倒置)
    
    com.str.ReverseStr
    
## 动态规划

### 最长回文子串

思路：
```
dp[i][j]表示“以s[i]开始s[j]结尾的回文串的长度。如果这个字符串不是回文串，让dp[i][j]=0”。显然，j>=i，只需往dp填j>=i的部分即可。

dp[i][j]的递推公式可以这么表述：

（1）首先对dp的对角线元素初始化为1，也就是当i==j时，dp[i][j]=1。

这很显然，每个单独的字符其实就是个长度为1的回文串。

（2）当j-i==1：

若s[i]==s[j]，则dp[i][j]=2；否则dp[i][j]=0。

解释：当j-i==1时，若s[i]==s[j]，则s[i]和s[j]可以组成一个长度为2的回文串。若s[i]！=s[j]，显然他们不可能组成回文串，dp[i][j]=0。

（3）当j-i>=2：

若s[i]==s[j]：若dp[i+1][j-1]>0，则dp[i][j]= dp[i + 1][j - 1] + 2;否则dp[i][j]= 0;

若s[i]！=s[j]：dp[i][j]=0。

解释：如果s[i]==s[j]，表明这个子串有可能是回文串。当去头去尾后它是回文串时，就可以在去头去尾的那个回文串长度基础上+2，得到它的长度。如果去头去尾后不是回文串，那这个子串一定不是回文串，回文串长度只能是0。

若s[i]！=s[j]，显然他们不可能组成回文串，dp[i][j]=0。

只需找到dp[i][j]的最大元素和它对应的i和j就可以得到结果“s中最长回文子串”。


另外还有一个要注意的点：因为需要访问dp[i+1][j-1]，因此i是从大到小的，j是从小到大的。j从0到size-1，i从j-1到0。
```
 
